{"componentChunkName":"component---src-templates-blog-post-js","path":"/blogs/teste-software","result":{"data":{"contentfulBlogs":{"id":"6a8cb05b-6ad9-5fd5-91b9-ea75d6741711","title":"Teste de Software","slug":"blogs/teste-software","featureImage":{"fluid":{"base64":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAYDBAj/xAAmEAACAgEDAwMFAAAAAAAAAAABAgMEEQAFEgYhMRMUQRYiUWGB/8QAFwEAAwEAAAAAAAAAAAAAAAAAAwUHCf/EACIRAAEDAwMFAAAAAAAAAAAAAAEAAhEDEiEEMXEiQYGx8P/aAAwDAQACEQMRAD8A2P1Dv7bZcrSRWofbVnPv6/DlKVZG4YOQFwRyJPbiDpX6a66l3Qb21C6d1szsZKEdgKkMBIKojlGLBeYwSR+PkgaZurOmBuW33JKNaBt1l4BZpiR2B7jl5H2lh28Z1W+hKY3jiaVeXaXqmORZmd5PU5dvLYxj9ZzjvrNqg/RihDx1eO0HnJMDIMCFRHB92Ez1WletE06qk5UeoqHKhsdwD8jOjUG07RU2OktSjCteurM4RfGWYsx/pJ0aSPtuNu33PtGG2V//2Q==","aspectRatio":1.3054830287206267,"src":"//images.ctfassets.net/e2ug6ccpuxz6/7IyIhq0ijQoK3asaaOMQJM/d3c2452d2a4b74d6940e4dd113850d0b/software-test.jpeg?w=1500&q=50","srcSet":"//images.ctfassets.net/e2ug6ccpuxz6/7IyIhq0ijQoK3asaaOMQJM/d3c2452d2a4b74d6940e4dd113850d0b/software-test.jpeg?w=375&h=287&q=50 375w,\n//images.ctfassets.net/e2ug6ccpuxz6/7IyIhq0ijQoK3asaaOMQJM/d3c2452d2a4b74d6940e4dd113850d0b/software-test.jpeg?w=750&h=575&q=50 750w,\n//images.ctfassets.net/e2ug6ccpuxz6/7IyIhq0ijQoK3asaaOMQJM/d3c2452d2a4b74d6940e4dd113850d0b/software-test.jpeg?w=1500&h=1149&q=50 1500w,\n//images.ctfassets.net/e2ug6ccpuxz6/7IyIhq0ijQoK3asaaOMQJM/d3c2452d2a4b74d6940e4dd113850d0b/software-test.jpeg?w=2250&h=1724&q=50 2250w,\n//images.ctfassets.net/e2ug6ccpuxz6/7IyIhq0ijQoK3asaaOMQJM/d3c2452d2a4b74d6940e4dd113850d0b/software-test.jpeg?w=3000&h=2298&q=50 3000w","srcWebp":"//images.ctfassets.net/e2ug6ccpuxz6/7IyIhq0ijQoK3asaaOMQJM/d3c2452d2a4b74d6940e4dd113850d0b/software-test.jpeg?w=1500&q=50&fm=webp","srcSetWebp":"//images.ctfassets.net/e2ug6ccpuxz6/7IyIhq0ijQoK3asaaOMQJM/d3c2452d2a4b74d6940e4dd113850d0b/software-test.jpeg?w=375&h=287&q=50&fm=webp 375w,\n//images.ctfassets.net/e2ug6ccpuxz6/7IyIhq0ijQoK3asaaOMQJM/d3c2452d2a4b74d6940e4dd113850d0b/software-test.jpeg?w=750&h=575&q=50&fm=webp 750w,\n//images.ctfassets.net/e2ug6ccpuxz6/7IyIhq0ijQoK3asaaOMQJM/d3c2452d2a4b74d6940e4dd113850d0b/software-test.jpeg?w=1500&h=1149&q=50&fm=webp 1500w,\n//images.ctfassets.net/e2ug6ccpuxz6/7IyIhq0ijQoK3asaaOMQJM/d3c2452d2a4b74d6940e4dd113850d0b/software-test.jpeg?w=2250&h=1724&q=50&fm=webp 2250w,\n//images.ctfassets.net/e2ug6ccpuxz6/7IyIhq0ijQoK3asaaOMQJM/d3c2452d2a4b74d6940e4dd113850d0b/software-test.jpeg?w=3000&h=2298&q=50&fm=webp 3000w","sizes":"(max-width: 1500px) 100vw, 1500px"}},"description":{"childMarkdownRemark":{"html":"<p>Teste de software basicamente é uma maneira de identificarmos a relação entre o que se espera e o que se tem como resultado, verificando onde o sistema atende ou deixa de atender os objetivos estabelecidos.\nAtravés dessa relação conseguimos garantir que o sistema atenda o máximo de requisitos possível.</p>\n<p>Fiz esse texto com base em anotações que havia feito quando estudei o assunto, tentei passar uma visão geral do por que utilizar testes, seu propósito e técnicas utilizadas, indicando também algumas ferramentas utilizadas por Dev’s Java.</p>\n<h2>Por que usar testes?</h2>\n<ul>\n<li>O testes ajudam no entendimento do sistema. Ele faz com que o desenvolvedor interaja com o produto e casos de uso.</li>\n<li>Melhora a estabilidade do sistema</li>\n<li>Ajuda a entrega de produtos que atendem as expectativas</li>\n<li>Previni rollback em casos de problemas em produção</li>\n<li>Pode ser usado como uma métrica de qualidade do código</li>\n<li>Ou seja, os testes pode nos dizer se o sistema funciona corretamente sobre condições específicas</li>\n</ul>\n<h2>O que testar?</h2>\n<ul>\n<li>Lógica do negócio, parte do código que está mais próximo das regras de negócio.</li>\n<li>Invariantes, expressões onde o valor não muda durante a execução do programa (um identificador por exemplo).</li>\n<li>Condições inesperadas, condições que não fazem parte da operação normal do sistema.</li>\n<li>Inputs errados, um valor negativo para um campo de quantidade de produtos por exemplo.</li>\n<li>Condições de limite, testa os extremos, mínimo, máximo, dentro ou fora dos limites, por exemplo pode haver 0 passageiros em um ônibus ou o valor máximo, não podendo ter menos que o mínimo nem ultrapassar o valor máximo.</li>\n<li>Regressão, garantir que funcionalidades antigas continuem funcionando após inclusão de outras ou melhorias.</li>\n</ul>\n<h2>Pirâmide de testes</h2>\n<p>A pirâmide de testes é um conceito criado por Mike Cohn, trazido em seu livro Succeeding with Agile que consiste em três etapas, são elas Unit Tests, Service Tests e User Interface Tests.\nEsse conceito foi criado para auxiliar e dar uma visão melhor de como aplicar e separar os tipos de testes, porém não precisamos nos prender somente a eles. Abaixo faço uma breve explicação de cada camada:</p>\n<h3>Teste Unitário</h3>\n<p>  Essa é a primeira fase da criação de testes, escrita pelos próprios desenvolvedores. Esse teste verifica o funcionamento da menor unidade de código testável (geralmente um método) de forma independente, fazendo com que cada teste possa ser executado sozinho. Para que utilizemos os testes isolados técnicas como builder, mocks são utilizadas para simular os objetos necessários.\nOs testes unitários são a base da pirâmide pois além de serem desenvolvidos primeiro (TDD) ajudando a guiar o design do código, são também mais rápidos, permitindo que sejam executados diversas vezes sem impactar tanto no desenvolvimento.</p>\n<h3>Teste de Integração</h3>\n<p>  Essa é a segunda etapa da pirâmide. Módulos que passaram pelos testes de unidade,  são combinados de acordo com as regras de negócio e testados em grupo. Os principais objetivos do teste de integração é verificar os requisitos funcionais de desempenho e confiabilidade, permitindo que encontremos erros de interface entre os componentes. Como o teste de integração utiliza conjunto de testes de unidade geralmente se torna menor que ele.</p>\n<h3>Teste do Sistema</h3>\n<p>  Essa é a última fase da automação de testes que entra no escopo dos testes black box, onde o testador não tem conhecimento da estrutura do projeto. Por exemplo para um site ele iria utilizar o browser para efetuar os testes, seriam testes de alto nível. Geralmente esses testes são mais complexos e demandam mais esforço para seu desenvolvimento, além de seu tempo de execução ser relativamente maior, por isso é preferível que seja aplicado somente nos principais fluxo, onde não possuem tantas alterações.</p>\n<h3>Teste de Aceitação</h3>\n<p>  Ainda podemos incluir esse último teste, onde é feita a última avaliação em que é definido se o sistema atende aos requisitos. Geralmente é feito por alguém da área de negócio ou com os próprios usuários em ambiente controlado.</p>\n<h3>Ferramentas de testes mais utilizadas:</h3>\n<p><strong>JUnit, TestNG</strong> - Frameworks de teste, possuem funcionalidades semelhantes apesar do JUnit ser mais conhecido e utilizado. A maioria das IDEs fornecem integração com JUnit, fazendo com que ele possa ser executado diretamente na IDE.</p>\n<p><strong>Mockito, PowerMock</strong> - principais frameworks para criar ou mockar objetos em testes unitários automatizados, permitindo que sejam executados de forma individual. Muito utilizados em conjunto com JUnit.</p>\n<p><strong>Arquillian</strong> - ferramenta de testes para JavaEE que permite o desenvolvedor criar de forma fácil testes de integração automáticos e testes de aceitação.</p>\n<p><strong>Cucumber, JBehave</strong> -  ferramentas que rodam testes automatizados de aceitação (high level) retornados em um desenvolvimento orientado a comportamento. Se você deseja implementar automação de testes web completa e simular o comportamento do usuário ele se torna uma boa opção. </p>\n<h2>Code Coverage</h2>\n<p>  Code Coverage é uma métrica utilizada para descrever o quanto o sistema está coberto pelos testes criados, quanto maior cobertura de código, provavelmente menor serão as chances de conter bugs ou funcionalidades incorretas se comparado com um sistema com pouca cobertura de código. Há várias métricas que podem ser utilizadas para esse cálculo, a mais básica é calculada pelo número de métodos / linhas de código executadas nos testes. A maioria das IDE’s possuem essa métrica.</p>\n<h3>Ferramentas que facilitam visualizar essas métricas:</h3>\n<ul>\n<li>JCov</li>\n<li>OpenClover</li>\n<li>EMMA</li>\n<li>JaCoCo</li>\n</ul>\n<h3>Qual deve ser a porcentagem de cobertura de código?</h3>\n<p>  Sempre devemos ter como objetivo alcançar 100% de cobertura porém nem sempre é possível. Muitos dizem que a maioria dos sistemas deve ter pelo menos 80% de cobertura de testes para que sejam considerados seguros.</p>\n<hr>\n<h2>Conclusão</h2>\n<p>  O mundo dos testes é realmente muito amplo, porém é um investimento cadas vez mais necessário e que com certeza trará grandes retornos conforme o time e produto forem evoluindo. Apesar de em um primeiro momento “assustar”  acredito que com o tempo os testes tendem a se tornar parte da cultura de desenvolvimento das empresas e se ficando cada vez mais ágeis de serem implementados após ser definido um padrão que melhor se adeque ao momento em que a empresa se encontra.</p>\n<p>  Espero que tenha ajudado assim como me ajudou a entender um pouco mais desse mundo dos testes, ainda que de maneira resumida. O próximo post será sobre <strong>Clean Code para Testes</strong>.</p>"}},"createdAt":"2020-06-13T15:47:51.015Z","updatedAt":"2020-07-06T19:00:11.524Z"},"contentfulSiteInformation":{"siteUrl":"https://lifecoding.com","twiteerHandle":"DonWilll"}},"pageContext":{"slug":"blogs/teste-software"}}}