{"componentChunkName":"component---src-templates-blog-post-js","path":"/blogs/alguns-fundamentos-da-orientacao-objeto","result":{"data":{"contentfulBlogs":{"id":"84f0087c-bab7-5b8c-a395-12256c4d2d2e","title":"Alguns Fundamentos da Orientação Objeto","slug":"/blogs/alguns-fundamentos-da-orientacao-objeto","featureImage":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAMAAABI111xAAAAilBMVEU1HHVSPYlCK35AKHw5IHhRPIhwX5xmU5VsWpmBcaefk7uOgLBvXZtsWpp7a6N/b6aEdqpRPIZSPodMN4NMNoNIMoBQPIaBc6f////+9vb85ueBcqeQg7Lo4ujr2t/6/P7+/v+/2ezD2+2QgrH0sLH1trf++vqPgrFKNIKShbOThLGSfquTg7CThrTlXNgRAAAACXBIWXMAABcRAAAXEQHKJvM/AAAAB3RJTUUH5AkPAgAe7floHgAAAFNJREFUCNdjYCAWMEIpKPgB5rFABDlQBKEqmfnAYm/+IQuKMwJN+MfA/BTMY4IIsgINYmGHKWGB2cgBUgkFUJXsDD+YmdkYuFFUsgqC7BH8j8fxAO13CXhFLV95AAAAAElFTkSuQmCC","aspectRatio":1.7777777777777777,"src":"//images.ctfassets.net/e2ug6ccpuxz6/18ZNTGLiqsZUOadteGwojO/65d31d10b4b6d2e6d806f20924719298/java-poo.png?w=1500&q=50","srcSet":"//images.ctfassets.net/e2ug6ccpuxz6/18ZNTGLiqsZUOadteGwojO/65d31d10b4b6d2e6d806f20924719298/java-poo.png?w=375&h=211&q=50 375w,\n//images.ctfassets.net/e2ug6ccpuxz6/18ZNTGLiqsZUOadteGwojO/65d31d10b4b6d2e6d806f20924719298/java-poo.png?w=750&h=422&q=50 750w,\n//images.ctfassets.net/e2ug6ccpuxz6/18ZNTGLiqsZUOadteGwojO/65d31d10b4b6d2e6d806f20924719298/java-poo.png?w=960&h=540&q=50 960w","srcWebp":"//images.ctfassets.net/e2ug6ccpuxz6/18ZNTGLiqsZUOadteGwojO/65d31d10b4b6d2e6d806f20924719298/java-poo.png?w=1500&q=50&fm=webp","srcSetWebp":"//images.ctfassets.net/e2ug6ccpuxz6/18ZNTGLiqsZUOadteGwojO/65d31d10b4b6d2e6d806f20924719298/java-poo.png?w=375&h=211&q=50&fm=webp 375w,\n//images.ctfassets.net/e2ug6ccpuxz6/18ZNTGLiqsZUOadteGwojO/65d31d10b4b6d2e6d806f20924719298/java-poo.png?w=750&h=422&q=50&fm=webp 750w,\n//images.ctfassets.net/e2ug6ccpuxz6/18ZNTGLiqsZUOadteGwojO/65d31d10b4b6d2e6d806f20924719298/java-poo.png?w=960&h=540&q=50&fm=webp 960w","sizes":"(max-width: 1500px) 100vw, 1500px"}},"description":{"childMarkdownRemark":{"html":"<h2>Programação OO vs Design OO</h2>\n<p>Muitas vezes pensamos que estamos utilizando orientação objeto simplesmente por acabar utilizando funcionalidades existentes na linguagem que a possui.\nÉ muito comum programarmos com linguagens  que utilizam essa funcionalidade sem estar usando Orientação Objeto de forma efetiva, ou seja, é mais que utilizar herança e polimorfismo que são funcionalidades básicas que utilizamos ao aprender uma linguagem.</p>\n<p>Com Design de Orientação Objeto aplicamos princípios que tornam nosso código mais efetivo.</p>\n<h2>O que é um objeto?</h2>\n<p>Quando iniciamos na programação tendemos a pensar em objetos como uma estrutura de dados + métodos, porém, ao invés disso objetos são definidos pelo que eles fazem, não pelo que eles contém.\nComo objetos são black-box as classes que irão utilizá-lo não sabem como funcionam (e nem deve precisar) mas efetua requisições para que realize determinada ação, mesmo não sabendo como ele faz o processamento.\nObjetos possuem responsabilidades, e podem executar um conjunto de operações que estejam coerentes e coesas com as mesmas.</p>\n<h2>Transparência</h2>\n<p>Ao visualizar um objeto deve estar claro para que ele foi criado. Podemos fazer um teste rápido, tente ler um código que você mesmo criou há dois meses ou mais, caso tenha dificuldade em entender, provavelmente está violando esse princípio. </p>\n<p>É preciso lembrar também que transparência não significa expor como seu objeto funciona e executa seus comandos.\nPor exemplo ao utilizar uma API para alguma finalidade você não necessariamente quer saber os detalhes de sua implementação e sim apenas consumir essa funcionalidade, por isso é importante que estes métodos tenham nomes claros em que fique óbvio seu objetivo.</p>\n<h2>Simplicidade (Design and Build incrementally)</h2>\n<p>“Tudo deve ser apresentado da maneira mais simples possível, porém não mais simples do que isso.” (Albert Einstein)</p>\n<p>Podemos aplicar essa frase dita por Albert Einstein também na programação, um objeto deve ser o mais simples possível, porém não tão simples a ponto de se tornar errado. </p>\n<p>Um objeto deveria fazer exatamente aquilo para que foi criado e nada mais. O código por si só não possui valor se ele não faz exatamente aquilo que deveria.\nA implementação de design patterns muitas vezes adicionam complexidade ao código e pode não ser a melhor escolha para se iniciar o desenvolvimento portanto busque sem escrever o código o mais simples possível, depois se for necessário algum tipo de refactoring, e esta modificação ficar melhor utilizando algum tipo de design pattern, adicione. </p>\n<p>Pode parecer um pouco errado dizer isso, porém é perfeitamente comum precisar realizar alterações em um código ao longo do seu desenvolvimento, por isso a importância da aplicação de boas práticas que facilitam muito essas mudanças.</p>\n<h2>Coesão e Acoplamento</h2>\n<p>Um objeto coeso está muito ligado ao princípio da responsabilidade única, ou seja, uma classe não deve assumir responsabilidades que não possuem relação com aquilo para qual foi criada. Os métodos e atributos que compõem uma classe devem sempre estar focados em resolver um problema específico.</p>\n<p>Acoplamento acontece quando duas coisas são conectadas entre si indiretamente, você altera uma e a outra também precisa ser alterada e isso pode causar diversos problemas que podem ser difíceis de serem identificados. Você deve ser capaz de alterar a implementação de uma classe sem causar impacto nos objetos que utilizam essa classe.</p>\n<p>Devemos sempre tentar maximizar a Coesão e minimizar o Acoplamento ainda que em alguns casos seja necessário.</p>\n<h2>Definindo Comportamento e Estado behavior and State</h2>\n<p>Estado está relacionado ao atributos da classe, cada classe possui um conjunto de atributos definidos e os valores atribuído a eles definem o seu estado.\nComportamento está relacionado aos métodos, que podem ser utilizados para alterar o estado do objeto.</p>\n<p>Exemplo com println( someString ).\nCaso queira exibir uma String com unicode não seria possível, seria necessário criar uma adaptação como abaixo:</p>\n<pre><code>new PrintWriter(\nnew BufferedWriter(\nnew OutputStreamWriter( System.out )))\n.println( someString );\n</code></pre>\n<p>O objeto que possui a informação deve fazer o trabalho, no caso do println() a String que possui a informação do texto que precisa ser exibido, então faria mais sentido solicitar a String que contém os caracteres para exibi-los. </p>\n<p>A maneira mais adequada de fazer um print seguindo esse padrão seria:\nsomeString.println( System.out )</p>\n<p>Caso seja preciso alterar o método println a escrita continuaria a mesma, ou seja, não impactaria em nada na parte externa ao código.</p>\n<h2>Extending Classes</h2>\n<p>O is-a teste, se A is-a B então faz sentido A extends B.</p>\n<p>Porém há algumas considerações que devem ser feitas, por exemplo:</p>\n<p>Um Gerente is-a Funcionário?</p>\n<p>A maioria responde sim para essa pergunta, mas as coisas podem ser um pouco mais complicadas. </p>\n<p>Considere o problema de um sistema de gerenciamento de ponto, nele Gerentes e Funcionários possuem responsabilidades diferentes que não podem ser sobrepostas.\nUm Gerente autoriza os dados nesse sistema e o Funcionário simplesmente preenche, ou seja as classes fazem coisas diferentes. O fato de um Gerente ser um Funcionário no mundo real é completamente irrelevante.</p>\n<p>A mesma pessoa pode acessar o sistema como Gerente e em outro momento acessar como Funcionário e isso também se torna irrelevante, o que importa são suas atribuições, e as atribuições de um Gerente não tem responsabilidades sobrepostas com as do Funcionário. Em consequência disso temos duas classes que não possuem conexão entre si.</p>\n<p>Há outras situações como por exemplo quando o Gerente e Funcionário fazem a mesma coisa porém são categorizados de forma diferente, nesse caso poderíamos utilizar a mesmo classe alterando somente a nomenclatura quando for implementada.\nA situação mais clara que faria sentido utilizar extends seria nos casos em que o Gerente realiza todas as funções de um Funcionário, porém também possui mais algumas outras.\nOu seja o Gerente é exatamente igual à um Funcionário podendo fazer algumas funções a mais.</p>\n<p>Is-a faz sentido se analisarmos pensando no mundo real, porém não necessariamente deve fazer sentido na programação e muitos o consideram como um anti-pattern, pois alterações na superclasse podem afetar suas subclasses e muitas vezes utilizar composição é o melhor caminho. </p>\n<p>O ideal é tentar usar alternativas e alguns dos diversos design pattern que nos ajudam a substituir o uso do extends.\nCaso seja realmente necessário ou melhore seu código utilizando herança, a classe deve ser projetada e documenta informando os efeitos da sobrescrição de cada método.</p>\n<h2>Conclusão</h2>\n<p>Estes são somente alguns exemplos de boas práticas e princípios que podem ser utilizados na programação Orientada a Objetos e já podemos ver que aplicando somente alguns deles podemos ter um ganho muito grande no desenvolvimento de software, existe uma diversidade muito grande que  não foi citada neste texto que também vale muito a pena conhecer. </p>\n<h3>Referências</h3>\n<p>Curso: <a href=\"https://www.pluralsight.com/courses/java-fundamentals-object-oriented-design\">PluralSight - Java Fundamentals OO</a></p>\n<p>Livro: <a href=\"https://www.amazon.com.br/dp/B07YBG67VP/ref=dp-kindle-redirect?_encoding=UTF8&#x26;btkr=1\" title=\"Java Efetivo\">Java Efetivo</a>, <a href=\"https://www.amazon.com.br/C%C3%B3digo-limpo-Robert-C-Martin/dp/8576082675/ref=sr_1_1?__mk_pt_BR=%C3%85M%C3%85%C5%BD%C3%95%C3%91&#x26;dchild=1&#x26;keywords=clean+code&#x26;qid=1596401479&#x26;s=books&#x26;sr=1-1\" title=\"Clean Code\">Clean Code</a></p>"}},"createdAt":"2020-06-13T15:47:49.564Z","updatedAt":"2020-08-15T22:07:52.613Z"},"contentfulSiteInformation":{"siteUrl":"https://lifecoding.com","twiteerHandle":"DonWilll"}},"pageContext":{"slug":"/blogs/alguns-fundamentos-da-orientacao-objeto"}}}